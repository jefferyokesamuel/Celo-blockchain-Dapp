"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TEST_OPTIONAL_IS_EIP712 = void 0;
var address_1 = require("@celo/base/lib/address");
var bignumber_js_1 = require("bignumber.js");
var ethereumjs_util_1 = require("ethereumjs-util");
var sign_typed_data_utils_1 = require("./sign-typed-data-utils");
// Compile-time check that Domain can be cast to type EIP712Object
exports.TEST_OPTIONAL_IS_EIP712 = {};
var TEST_TYPES = [
    {
        primaryType: 'Mail',
        types: {
            Mail: [
                { name: 'from', type: 'address' },
                { name: 'to', type: 'address' },
                { name: 'contents', type: 'string' },
            ],
        },
        typeEncoding: 'Mail(address from,address to,string contents)',
        zero: {
            from: address_1.NULL_ADDRESS,
            to: address_1.NULL_ADDRESS,
            contents: '',
        },
        examples: [
            {
                data: {
                    from: '0x000000000000000000000000000000000000a1ce',
                    to: '0x0000000000000000000000000000000000000b0b',
                    contents: 'hello bob!',
                },
                dataEncoding: Buffer.concat([
                    Buffer.from('000000000000000000000000000000000000000000000000000000000000a1ce', 'hex'),
                    Buffer.from('0000000000000000000000000000000000000000000000000000000000000b0b', 'hex'),
                    (0, ethereumjs_util_1.keccak)('hello bob!'),
                ]),
            },
            {
                data: {
                    from: '0x000000000000000000000000000000000000a1ce',
                    to: '0x0000000000000000000000000000000000000b0b',
                    // Should be interpreted as a UTF-8 encoded string. Not hex encoded bytes.
                    contents: '0xdeadbeef',
                },
                dataEncoding: Buffer.concat([
                    Buffer.from('000000000000000000000000000000000000000000000000000000000000a1ce', 'hex'),
                    Buffer.from('0000000000000000000000000000000000000000000000000000000000000b0b', 'hex'),
                    (0, ethereumjs_util_1.keccak)(Buffer.from('0xdeadbeef', 'utf8')),
                ]),
            },
        ],
    },
    {
        primaryType: 'Transaction',
        types: {
            Transaction: [
                { name: 'from', type: 'Person' },
                { name: 'to', type: 'Person' },
                { name: 'tx', type: 'Asset' },
            ],
            Person: [
                { name: 'wallet', type: 'address' },
                { name: 'name', type: 'string' },
            ],
            Asset: [
                { name: 'token', type: 'address' },
                { name: 'amount', type: 'uint256' },
            ],
        },
        typeEncoding: 'Transaction(Person from,Person to,Asset tx)Asset(address token,uint256 amount)Person(address wallet,string name)',
        zero: {
            from: { wallet: address_1.NULL_ADDRESS, name: '' },
            to: { wallet: address_1.NULL_ADDRESS, name: '' },
            tx: { token: address_1.NULL_ADDRESS, amount: 0 },
        },
        examples: [
            {
                data: {
                    from: { wallet: '0x000000000000000000000000000000000000a1ce', name: 'Alice' },
                    to: { name: 'Bob', wallet: '0x0000000000000000000000000000000000000b0b' },
                    tx: {
                        token: '0x000000000000000000000000000000000000ce10',
                        amount: new bignumber_js_1.BigNumber('5e+18'),
                    },
                },
                dataEncoding: Buffer.concat([
                    (0, ethereumjs_util_1.keccak)(Buffer.concat([
                        (0, ethereumjs_util_1.keccak)('Person(address wallet,string name)'),
                        Buffer.from('000000000000000000000000000000000000000000000000000000000000a1ce', 'hex'),
                        (0, ethereumjs_util_1.keccak)('Alice'),
                    ])),
                    (0, ethereumjs_util_1.keccak)(Buffer.concat([
                        (0, ethereumjs_util_1.keccak)('Person(address wallet,string name)'),
                        Buffer.from('0000000000000000000000000000000000000000000000000000000000000b0b', 'hex'),
                        (0, ethereumjs_util_1.keccak)('Bob'),
                    ])),
                    (0, ethereumjs_util_1.keccak)(Buffer.concat([
                        (0, ethereumjs_util_1.keccak)('Asset(address token,uint256 amount)'),
                        Buffer.from('000000000000000000000000000000000000000000000000000000000000ce10', 'hex'),
                        Buffer.from('0000000000000000000000000000000000000000000000004563918244F40000', 'hex'),
                    ])),
                ]),
            },
        ],
    },
    {
        primaryType: 'Nested',
        types: {
            Bird: [
                { name: 'species', type: 'string' },
                { name: 'color', type: 'Color' },
                { name: 'nest', type: 'Nested' },
            ],
            Color: [
                { name: 'red', type: 'uint8' },
                { name: 'green', type: 'uint8' },
                { name: 'blue', type: 'uint8' },
            ],
            Nested: [
                { name: 'nest', type: 'Nested' },
                { name: 'eggs', type: 'Egg[][]' },
            ],
            Egg: [
                { name: 'bird', type: 'Bird' },
                { name: 'age', type: 'uint256' },
            ],
            // An orphaned type should have no effect on the encoding.
            Orphan: [],
        },
        typeEncoding: 'Nested(Nested nest,Egg[][] eggs)Bird(string species,Color color,Nested nest)Color(uint8 red,uint8 green,uint8 blue)Egg(Bird bird,uint256 age)',
        // Although this recurive type definition can be encoded with EIP-712, no instance of it can.
        examples: [],
    },
    {
        primaryType: 'GameBoard',
        types: {
            GameBoard: [{ name: 'grid', type: 'Tile[][]' }],
            Tile: [
                { name: 'occupied', type: 'bool' },
                { name: 'occupantId', type: 'uint8' },
            ],
        },
        typeEncoding: 'GameBoard(Tile[][] grid)Tile(bool occupied,uint8 occupantId)',
        zero: {
            grid: [],
        },
        examples: [
            {
                data: {
                    grid: [
                        [
                            { occupied: true, occupantId: 5 },
                            { occupied: false, occupantId: 0 },
                        ],
                        [
                            { occupied: true, occupantId: new bignumber_js_1.BigNumber(160) },
                            { occupied: true, occupantId: 161 },
                        ],
                    ],
                },
                dataEncoding: Buffer.concat([
                    (0, ethereumjs_util_1.keccak)(Buffer.concat([
                        (0, ethereumjs_util_1.keccak)(Buffer.concat([
                            (0, ethereumjs_util_1.keccak)(Buffer.concat([
                                (0, ethereumjs_util_1.keccak)('Tile(bool occupied,uint8 occupantId)'),
                                Buffer.from('0000000000000000000000000000000000000000000000000000000000000001', 'hex'),
                                Buffer.from('0000000000000000000000000000000000000000000000000000000000000005', 'hex'),
                            ])),
                            (0, ethereumjs_util_1.keccak)(Buffer.concat([
                                (0, ethereumjs_util_1.keccak)('Tile(bool occupied,uint8 occupantId)'),
                                Buffer.from('0000000000000000000000000000000000000000000000000000000000000000', 'hex'),
                                Buffer.from('0000000000000000000000000000000000000000000000000000000000000000', 'hex'),
                            ])),
                        ])),
                        (0, ethereumjs_util_1.keccak)(Buffer.concat([
                            (0, ethereumjs_util_1.keccak)(Buffer.concat([
                                (0, ethereumjs_util_1.keccak)('Tile(bool occupied,uint8 occupantId)'),
                                Buffer.from('0000000000000000000000000000000000000000000000000000000000000001', 'hex'),
                                Buffer.from('00000000000000000000000000000000000000000000000000000000000000a0', 'hex'),
                            ])),
                            (0, ethereumjs_util_1.keccak)(Buffer.concat([
                                (0, ethereumjs_util_1.keccak)('Tile(bool occupied,uint8 occupantId)'),
                                Buffer.from('0000000000000000000000000000000000000000000000000000000000000001', 'hex'),
                                Buffer.from('00000000000000000000000000000000000000000000000000000000000000a1', 'hex'),
                            ])),
                        ])),
                    ])),
                ]),
            },
        ],
    },
];
describe('encodeType()', function () {
    var e_1, _a;
    var _loop_1 = function (primaryType, types, typeEncoding) {
        it("should encode type " + primaryType + " correctly", function () {
            expect((0, sign_typed_data_utils_1.encodeType)(primaryType, types)).toEqual(typeEncoding);
        });
    };
    try {
        for (var TEST_TYPES_1 = __values(TEST_TYPES), TEST_TYPES_1_1 = TEST_TYPES_1.next(); !TEST_TYPES_1_1.done; TEST_TYPES_1_1 = TEST_TYPES_1.next()) {
            var _b = TEST_TYPES_1_1.value, primaryType = _b.primaryType, types = _b.types, typeEncoding = _b.typeEncoding;
            _loop_1(primaryType, types, typeEncoding);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (TEST_TYPES_1_1 && !TEST_TYPES_1_1.done && (_a = TEST_TYPES_1.return)) _a.call(TEST_TYPES_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
});
describe('typeHash()', function () {
    var e_2, _a;
    var _loop_2 = function (primaryType, types, typeEncoding) {
        it("should hash type " + primaryType + " correctly", function () {
            expect((0, sign_typed_data_utils_1.typeHash)(primaryType, types)).toEqual((0, ethereumjs_util_1.keccak)(typeEncoding));
        });
    };
    try {
        for (var TEST_TYPES_2 = __values(TEST_TYPES), TEST_TYPES_2_1 = TEST_TYPES_2.next(); !TEST_TYPES_2_1.done; TEST_TYPES_2_1 = TEST_TYPES_2.next()) {
            var _b = TEST_TYPES_2_1.value, primaryType = _b.primaryType, types = _b.types, typeEncoding = _b.typeEncoding;
            _loop_2(primaryType, types, typeEncoding);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (TEST_TYPES_2_1 && !TEST_TYPES_2_1.done && (_a = TEST_TYPES_2.return)) _a.call(TEST_TYPES_2);
        }
        finally { if (e_2) throw e_2.error; }
    }
});
describe('encodeData()', function () {
    var e_3, _a;
    var _loop_3 = function (primaryType, types, examples) {
        if (examples.length > 0) {
            it("should encode data " + primaryType + " correctly", function () {
                var e_4, _a;
                try {
                    for (var examples_1 = (e_4 = void 0, __values(examples)), examples_1_1 = examples_1.next(); !examples_1_1.done; examples_1_1 = examples_1.next()) {
                        var _b = examples_1_1.value, data = _b.data, dataEncoding = _b.dataEncoding;
                        expect((0, sign_typed_data_utils_1.encodeData)(primaryType, data, types)).toEqual(dataEncoding);
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (examples_1_1 && !examples_1_1.done && (_a = examples_1.return)) _a.call(examples_1);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
            });
        }
    };
    try {
        for (var TEST_TYPES_3 = __values(TEST_TYPES), TEST_TYPES_3_1 = TEST_TYPES_3.next(); !TEST_TYPES_3_1.done; TEST_TYPES_3_1 = TEST_TYPES_3.next()) {
            var _b = TEST_TYPES_3_1.value, primaryType = _b.primaryType, types = _b.types, examples = _b.examples;
            _loop_3(primaryType, types, examples);
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (TEST_TYPES_3_1 && !TEST_TYPES_3_1.done && (_a = TEST_TYPES_3.return)) _a.call(TEST_TYPES_3);
        }
        finally { if (e_3) throw e_3.error; }
    }
});
describe('structHash()', function () {
    var e_5, _a;
    var _loop_4 = function (primaryType, types, examples) {
        if (examples.length > 0) {
            it("should hash data " + primaryType + " correctly", function () {
                var e_6, _a;
                try {
                    for (var examples_2 = (e_6 = void 0, __values(examples)), examples_2_1 = examples_2.next(); !examples_2_1.done; examples_2_1 = examples_2.next()) {
                        var _b = examples_2_1.value, data = _b.data, dataEncoding = _b.dataEncoding;
                        var expected = (0, ethereumjs_util_1.keccak)(Buffer.concat([(0, sign_typed_data_utils_1.typeHash)(primaryType, types), dataEncoding]));
                        expect((0, sign_typed_data_utils_1.structHash)(primaryType, data, types)).toEqual(expected);
                    }
                }
                catch (e_6_1) { e_6 = { error: e_6_1 }; }
                finally {
                    try {
                        if (examples_2_1 && !examples_2_1.done && (_a = examples_2.return)) _a.call(examples_2);
                    }
                    finally { if (e_6) throw e_6.error; }
                }
            });
        }
    };
    try {
        for (var TEST_TYPES_4 = __values(TEST_TYPES), TEST_TYPES_4_1 = TEST_TYPES_4.next(); !TEST_TYPES_4_1.done; TEST_TYPES_4_1 = TEST_TYPES_4.next()) {
            var _b = TEST_TYPES_4_1.value, primaryType = _b.primaryType, types = _b.types, examples = _b.examples;
            _loop_4(primaryType, types, examples);
        }
    }
    catch (e_5_1) { e_5 = { error: e_5_1 }; }
    finally {
        try {
            if (TEST_TYPES_4_1 && !TEST_TYPES_4_1.done && (_a = TEST_TYPES_4.return)) _a.call(TEST_TYPES_4);
        }
        finally { if (e_5) throw e_5.error; }
    }
});
describe('zeroValue()', function () {
    var e_7, _a;
    var _loop_5 = function (primaryType, types, zero) {
        if (zero !== undefined) {
            it("should return zero value for " + primaryType + " correctly", function () {
                expect((0, sign_typed_data_utils_1.zeroValue)(primaryType, types)).toEqual(zero);
            });
        }
    };
    try {
        for (var TEST_TYPES_5 = __values(TEST_TYPES), TEST_TYPES_5_1 = TEST_TYPES_5.next(); !TEST_TYPES_5_1.done; TEST_TYPES_5_1 = TEST_TYPES_5.next()) {
            var _b = TEST_TYPES_5_1.value, primaryType = _b.primaryType, types = _b.types, zero = _b.zero;
            _loop_5(primaryType, types, zero);
        }
    }
    catch (e_7_1) { e_7 = { error: e_7_1 }; }
    finally {
        try {
            if (TEST_TYPES_5_1 && !TEST_TYPES_5_1.done && (_a = TEST_TYPES_5.return)) _a.call(TEST_TYPES_5);
        }
        finally { if (e_7) throw e_7.error; }
    }
});
//# sourceMappingURL=sign-typed-data-utils.test.js.map