"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.proxySend = exports.proxyCall = exports.tupleParser = exports.stringIdentity = exports.identity = exports.solidityBytesToString = exports.bufferToSolidityBytes = exports.stringToSolidityBytes = exports.unixSecondsTimestampToDateString = exports.blocksToDurationString = exports.secondsToDurationString = exports.valueToFrac = exports.valueToInt = exports.valueToFixidityString = exports.valueToString = exports.fixidityValueToBigNumber = exports.valueToBigNumber = exports.BaseWrapper = void 0;
var address_1 = require("@celo/base/lib/address");
var collections_1 = require("@celo/base/lib/collections");
var connect_1 = require("@celo/connect");
var fixidity_1 = require("@celo/utils/lib/fixidity");
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var versions_1 = require("../versions");
/** Base ContractWrapper */
var BaseWrapper = /** @class */ (function () {
    function BaseWrapper(kit, contract) {
        var _this = this;
        this.kit = kit;
        this.contract = contract;
        this.events = this.contract.events;
        this.eventTypes = Object.keys(this.events).reduce(function (acc, key) {
            var _a;
            return (__assign(__assign({}, acc), (_a = {}, _a[key] = key, _a)));
        }, {});
        this.methodIds = Object.keys(this.contract.methods).reduce(function (acc, method) {
            var methodABI = _this.contract.options.jsonInterface.find(function (item) { return item.name === method; });
            acc[method] =
                methodABI === undefined
                    ? '0x'
                    : _this.kit.connection.getAbiCoder().encodeFunctionSignature(methodABI);
            return acc;
        }, {});
    }
    Object.defineProperty(BaseWrapper.prototype, "address", {
        /** Contract address */
        get: function () {
            return this.contract.options.address;
        },
        enumerable: false,
        configurable: true
    });
    BaseWrapper.prototype.version = function () {
        return __awaiter(this, void 0, void 0, function () {
            var raw;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!!this._version) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.contract.methods.getVersionNumber().call()
                            // @ts-ignore conditional type
                        ];
                    case 1:
                        raw = _a.sent();
                        // @ts-ignore conditional type
                        this._version = versions_1.ContractVersion.fromRaw(raw);
                        _a.label = 2;
                    case 2: return [2 /*return*/, this._version];
                }
            });
        });
    };
    BaseWrapper.prototype.onlyVersionOrGreater = function (version) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.version()];
                    case 1:
                        if (!(_a.sent()).isAtLeast(version)) {
                            throw new Error("Bytecode version " + this._version + " is not compatible with " + version + " yet");
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /** Contract getPastEvents */
    BaseWrapper.prototype.getPastEvents = function (event, options) {
        return this.contract.getPastEvents(event, options);
    };
    return BaseWrapper;
}());
exports.BaseWrapper = BaseWrapper;
var valueToBigNumber = function (input) { return new bignumber_js_1.default(input); };
exports.valueToBigNumber = valueToBigNumber;
var fixidityValueToBigNumber = function (input) { return (0, fixidity_1.fromFixed)(new bignumber_js_1.default(input)); };
exports.fixidityValueToBigNumber = fixidityValueToBigNumber;
var valueToString = function (input) { return (0, exports.valueToBigNumber)(input).toFixed(); };
exports.valueToString = valueToString;
var valueToFixidityString = function (input) {
    return (0, fixidity_1.toFixed)((0, exports.valueToBigNumber)(input)).toFixed();
};
exports.valueToFixidityString = valueToFixidityString;
var valueToInt = function (input) {
    return (0, exports.valueToBigNumber)(input).integerValue().toNumber();
};
exports.valueToInt = valueToInt;
var valueToFrac = function (numerator, denominator) {
    return (0, exports.valueToBigNumber)(numerator).div((0, exports.valueToBigNumber)(denominator));
};
exports.valueToFrac = valueToFrac;
var TimeDurations;
(function (TimeDurations) {
    TimeDurations[TimeDurations["millennium"] = 31536000000000] = "millennium";
    TimeDurations[TimeDurations["century"] = 3153600000000] = "century";
    TimeDurations[TimeDurations["decade"] = 315360000000] = "decade";
    TimeDurations[TimeDurations["year"] = 31536000000] = "year";
    TimeDurations[TimeDurations["quarter"] = 7776000000] = "quarter";
    TimeDurations[TimeDurations["month"] = 2592000000] = "month";
    TimeDurations[TimeDurations["week"] = 604800000] = "week";
    TimeDurations[TimeDurations["day"] = 86400000] = "day";
    TimeDurations[TimeDurations["hour"] = 3600000] = "hour";
    TimeDurations[TimeDurations["minute"] = 60000] = "minute";
    TimeDurations[TimeDurations["second"] = 1000] = "second";
    TimeDurations[TimeDurations["millisecond"] = 1] = "millisecond";
})(TimeDurations || (TimeDurations = {}));
// taken mostly from https://gist.github.com/RienNeVaPlus/024de3431ae95546d60f2acce128a7e2
function secondsToDurationString(durationSeconds, outputUnits) {
    if (outputUnits === void 0) { outputUnits = ['year', 'month', 'week', 'day', 'hour', 'minute', 'second']; }
    var durationMilliseconds = (0, exports.valueToBigNumber)(durationSeconds)
        .times(TimeDurations.second)
        .toNumber();
    if (durationMilliseconds <= 0) {
        return 'past';
    }
    var durations = outputUnits.reduce(function (res, key) {
        var unitDuration = TimeDurations[key];
        var value = Math.floor(durationMilliseconds / unitDuration);
        durationMilliseconds -= value * unitDuration;
        return res.set(key, value);
    }, new Map());
    var s = '';
    durations.forEach(function (value, unit) {
        if (value > 0) {
            s += s !== '' ? ', ' : '';
            s += value + " " + unit + (value > 1 ? 's' : '');
        }
    });
    return s;
}
exports.secondsToDurationString = secondsToDurationString;
var blocksToDurationString = function (input) {
    return secondsToDurationString((0, exports.valueToBigNumber)(input).times(5));
}; // TODO: fetch blocktime
exports.blocksToDurationString = blocksToDurationString;
var DATE_TIME_OPTIONS = {
    year: 'numeric',
    month: 'short',
    weekday: 'short',
    day: 'numeric',
    hour: 'numeric',
    minute: 'numeric',
    timeZoneName: 'short',
};
var unixSecondsTimestampToDateString = function (input) {
    var date = new Date((0, exports.valueToInt)(input) * TimeDurations.second);
    return Intl.DateTimeFormat('default', DATE_TIME_OPTIONS).format(date);
};
exports.unixSecondsTimestampToDateString = unixSecondsTimestampToDateString;
var stringToSolidityBytes = function (input) { return (0, address_1.ensureLeading0x)(input); };
exports.stringToSolidityBytes = stringToSolidityBytes;
var bufferToSolidityBytes = function (input) { return (0, exports.stringToSolidityBytes)((0, address_1.bufferToHex)(input)); };
exports.bufferToSolidityBytes = bufferToSolidityBytes;
var solidityBytesToString = function (input) {
    if (input === null || input === undefined || typeof input === 'string') {
        return input;
    }
    else if (Array.isArray(input)) {
        var hexString = input.reduce(function (acc, num) { return acc + num.toString(16).padStart(2, '0'); }, '');
        return (0, address_1.ensureLeading0x)(hexString);
    }
    else {
        throw new Error('Unexpected input type for solidity bytes');
    }
};
exports.solidityBytesToString = solidityBytesToString;
/** Identity Parser */
var identity = function (a) { return a; };
exports.identity = identity;
var stringIdentity = function (x) { return x; };
exports.stringIdentity = stringIdentity;
function tupleParser() {
    var parsers = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        parsers[_i] = arguments[_i];
    }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return (0, collections_1.zip)(function (parser, input) { return parser(input); }, parsers, args);
    };
}
exports.tupleParser = tupleParser;
function proxyCall() {
    var callArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        callArgs[_i] = arguments[_i];
    }
    if (callArgs.length === 3 && callArgs[1] != null) {
        var methodFn_1 = callArgs[0];
        var parseInputArgs_1 = callArgs[1];
        var parseOutput_1 = callArgs[2];
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return methodFn_1.apply(void 0, parseInputArgs_1.apply(void 0, args)).call()
                .then(parseOutput_1);
        };
    }
    else if (callArgs.length === 3) {
        var methodFn_2 = callArgs[0];
        var parseOutput_2 = callArgs[2];
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return methodFn_2.apply(void 0, args).call()
                .then(parseOutput_2);
        };
    }
    else if (callArgs.length === 2) {
        var methodFn_3 = callArgs[0];
        var parseInputArgs_2 = callArgs[1];
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return methodFn_3.apply(void 0, parseInputArgs_2.apply(void 0, args)).call();
        };
    }
    else {
        var methodFn_4 = callArgs[0];
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return methodFn_4.apply(void 0, args).call();
        };
    }
}
exports.proxyCall = proxyCall;
/**
 * Creates a proxy to send a tx on a web3 native contract method.
 *
 * There are 2 cases:
 *  - call methodFn (no pre or post parsing)
 *  - preParse arguments & call methodFn
 *
 * @param methodFn Web3 methods function
 * @param preParse [optional] preParse function, tranforms arguments into `methodFn` expected inputs
 */
function proxySend(kit) {
    var sendArgs = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sendArgs[_i - 1] = arguments[_i];
    }
    if (sendArgs.length === 2) {
        var methodFn_5 = sendArgs[0];
        var preParse_1 = sendArgs[1];
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return (0, connect_1.toTransactionObject)(kit.connection, methodFn_5.apply(void 0, preParse_1.apply(void 0, args)));
        };
    }
    else {
        var methodFn_6 = sendArgs[0];
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return (0, connect_1.toTransactionObject)(kit.connection, methodFn_6.apply(void 0, args));
        };
    }
}
exports.proxySend = proxySend;
//# sourceMappingURL=BaseWrapper.js.map